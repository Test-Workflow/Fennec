---- config
# Basic config options.
title: Modern perl testing with Fennec
indent: 5
height: 34
width: 100
skip: 0
---- center
Modern perl testing with Fennec

by Chad 'Exodist' Granum

----
== Brief introduction to testing

+ * Tests are code to verify that other code does what it should

+ * Tests can often be divided into 2 types, Unit and Integration

+ * There are usually 2 pieces involved:
+  * A producer, which generates output
+  * A consumer or harness, which make use of the output

+ * Fennec is a producer, not a consumer

----
== Testing Tools

 * Test::Builder is a screwdriver base with many different heads

+ * Test utilities that don't work with TB are hammers

+ * Fennec is a toolbox, any tools inside it will work together

----
== Fennec is a test tool manager, or toolbox

 * Examples

 * Workflow Management

 * Test files are all objects

 * Assertion Library management
   (Works with Test::Builder)

 * Test Grouping

 * Result output formatting

 * A versatile runner

 * Test File Types (finding test files)

 * Parallelization

 * More examples
---- perl
package TEST::MyTest;
use strict;
use warnings;
use Fennec;

# If the module specified is not installed all tests will be skipped
use_or_skip 'Module::Name';

# Traditional script style works fine
ok( 1, "Not grouped" );
is( 'a', 'a', "" );
...

#It is much better to put tests into parallelizable groups.
tests hello_world_group => sub {
    my $self = shift;
    ok( 1, "Hello world" );
};

1;

---- perl
package TEST::MyTest;
use strict;
use warnings;
use Fennec;

describe 'my group' => sub {
    my $self = shift;

    before_each { $self->load_data };
    after_each { $self->unload_data };

    # it is an alias to 'tests'
    it 'my test' => sub {
        my $self = shift;
        ok( 1, 'spec test!' );
    };

    # Nested!
    describe ...;
};

1;
---- perl

cases {
    my $self = shift;
    case a => sub {
        my $self = shift;
        $self->reset_data( 'a' );
    }
    case b => sub {
        my $self = shift;
        $self->reset_data( 'b' );
    }
    tests a => sub {
        my $self = shift;
        ok( $self->have_data, "have data" );
    }
    tests b => sub {
        my $self = shift;
        ok( $self->works, "it works" );
    }
}

---- perl
    sub setup_my_setup {
        my $self = shift;
        print "methods prefixed by setup_ will be run before tests defined as methods.";
    }

    sub test_method_as_test_by_prefix {
        my $self = shift;
        ok( 1, "methods prefixed by test_ will be run as method." );
    }

    sub teardown_my_teardown {
        my $self = shift;
        print "method prefixed by teardown_ will be run after tests defined as methods."
    }

----
== Limitations of a screwdriver

 * Test::Builder excels as a base for tools that provide assertion functions

 * Test::Builder does nothing to address workflows

+== Whats a workflow?

+ * A way to structure tests when writing them

+ * A way to structure how tests are run

+ * A way to provide fixture data

+ * A way to setup and teardown an environment around the test
----
== Problems with workflow implementations

 * Often require a 'runner' to take control.

 * Usually do not work well together



+For example, Test::Class Uses a .t file to find, load, and run Test::Class tests.

 * If 2 'runners' find files that look the same (t/.../*.pm) they may stomp eachother

 * What if you want to mix multiple workflows?



+Fennec to the rescue:

 * Fennec provides a base for creating workflows that work together

 * Fennec provides the runner, workflows can simply share it

----
== Fennec Workflow Management

 * Fennec::Workflow base class for custom workflows

 * Tools to simplify defining a workflow in tests

 * Workflows hold child workflows and test sets

 * Workflows return self-contained TestSet objects to the runner

 * Every test file has a 'root' workflow

 * All test groups and workflows are nested within the root workflow

----
== Workflows provided with Fennec

 * Basic - Test groups and child workflows

 * SPEC - An implementation of Ruby's RSPEC for perl

 * Case - Run a set of test groups under multiple cases

 * Module - Similar to Test::Class, tests are methods.
----
== Overview of a workflow structure
-- Root Workflow
   |- Test Group
   |- Another Test Group
   |- Child Workflow
   |  |- Test Group
   |  |- ...
   |
   |- Another Child
      |- Test Group

The workflow process:
 * Load file
   * Create root workflow
   * Add workflows and testgroups defined at package level

 * Initialize/Build child workflows
  * Build workflows to depth

 * Get test sets from each workflow to depth

 * Run test sets
----
== Test files are objects

 * Base class
 * Meta
  * Root workflow
 * Construction and init

----
== Assertion Library management
 * Death based asserts
 * Fennec Asserts
 * Test::Builder asserts
   * TBCore
   * Test Builder overrides
----
== Test Grouping
 * tests name => sub {}
 * tests name => ( %options )
 * SubSet
 * Spec
 * Case
 * Random
----
== Result output formatting
 * TAP
 * Handler base
 * Custom Handlers
 * Failure collector
----
== A versatile runner
 * Proto
  * Environment
  * Config
  * Default
  * specified
----
== Test File Types (finding test files)
 * Find by path
 * Verify file
 * Loading
----
== Parallelization
 * parallel files
 * parallel tests
  * Grouping
 * Collector
---- perl
== Here is a typical Test::Builder based test

== t/MyModule.t
#!/usr/bin/perl

use strict;
use warnings;
use Test::More;

use_ok( 'MyModule' );

# Sanity
can_ok( 'MyModule', qw/a b/ );
isa_ok( 'MyModule', 'OtherModule' );

#Check defaults
my $one = MyModule->new;
is( MyModule->a, 'a', "default for a" );
is( MyModule->b, 'b', "default for b" );

#Set values
my $two = MyModule->new( a => 'A', b => 'B' );
is( MyModule->a, 'A', "construct value a" );
is( MyModule->b, 'B', "construct value b" );

done_testing;

---- perl
== Here is that same test converted to fennec

== t/MyModule.t
#!/usr/bin/perl
package TEST::MyModule;
use strict;
use warnings;
use Fennec::Standalone;

use_ok( 'MyModule' );

# Sanity
can_ok( 'MyModule', qw/a b/ );
isa_ok( 'MyModule', 'OtherModule' );

#Check defaults
my $one = MyModule->new;
is( MyModule->a, 'a', "default for a" );
is( MyModule->b, 'b', "default for b" );

#Set values
my $two = MyModule->new( a => 'A', b => 'B' );
is( MyModule->a, 'A', "construct value a" );
is( MyModule->b, 'B', "construct value b" );

done_testing;

----
== Differences

+ * The test file declares a package

+ * use Fennec instead of use Test::XXX

---- perl
== Here is that same test converted to fennec

== t/MyModule.t
#!/usr/bin/perl
package TEST::MyModule;
use strict;
use warnings;
use Fennec::Standalone;

use_ok( 'MyModule' );

# Sanity
can_ok( 'MyModule', qw/a b/ );
isa_ok( 'MyModule', 'OtherModule' );

#Check defaults
my $one = MyModule->new;
is( MyModule->a, 'a', "default for a" );
is( MyModule->b, 'b', "default for b" );

#Set values
my $two = MyModule->new( a => 'A', b => 'B' );
is( MyModule->a, 'A', "construct value a" );
is( MyModule->b, 'B', "construct value b" );

done_testing;

---- perl
== Here is that same test written the fennec way

== t/MyModule.pm
package TEST::MyModule;
use strict;
use warnings;
use Fennec;

use_ok( 'MyModule' );

tests Sanity => sub {
    my $self = shift;
    can_ok( 'MyModule', qw/a b/ );
    isa_ok( 'MyModule', 'OtherModule' );
};

tests 'Check defaults' => sub {
    my $one = MyModule->new;
    is( MyModule->a, 'a', "default for a" );
    is( MyModule->b, 'b', "default for b" );
};

tests 'Set values' => sub {
    my $one = MyModule->new( a => 'A', b => 'B' );
    is( MyModule->a, 'A', "construct value a" );
    is( MyModule->b, 'B', "construct value b" );
};

1;
----
== differences

+ * The test file is a module (.pm)

+ * The test groups are named and declared seperately

+ * done_testing() is not required

+ * Test groups are methods
  (notice: $self = shift; in the first group)

----
== The End
