---- config
# Basic config options.
title: Modern perl testing with Fennec
indent: 5
height: 34
width: 100
skip: 0
---- center
Modern perl testing with Fennec

by Chad 'Exodist' Granum

----
== Brief introduction to testing

+ * Tests are code to verify that other code does what it should

+ * Tests can often be divided into 2 types, Unit and Integration

+ * There are usually 2 pieces involved:
+  * A producer, which generates output
+  * A consumer or harness, which make use of the output

+ * Fennec is a producer, not a consumer

----
== Testing Tools

 * Test::Builder is a screwdriver base with many different heads

+ * Test utilities that don't work with TB are hammers

+ * Fennec is a toolbox, any tools inside it will work together

----
== Fennec is a test tool manager, or toolbox

 * Workflow Management

 * Test files are all objects

 * Assertion Library management
   (Works with Test::Builder)

 * Test Grouping

 * Result Handling (output)

 * A Versatile Runner

 * Test File Types (finding test files)

 * Parallelization

---- center

Fennec Examples

---- perl
package TEST::MyTest;
use strict;
use warnings;
use Fennec;

# If the module specified is not installed all tests will be skipped
use_or_skip 'Module::Name';

# Traditional script style works fine
ok( 1, "Not grouped" );
is( 'a', 'a', "" );
...

#It is much better to put tests into parallelizable groups.
tests hello_world_group => sub {
    my $self = shift;
    ok( 1, "Hello world" );
};

1;

---- perl
package TEST::MyTest;
use strict;
use warnings;
use Fennec;

describe 'my group' => sub {
    my $self = shift;

    before_each { $self->load_data };
    after_each { $self->unload_data };

    # it is an alias to 'tests'
    it 'my test' => sub {
        my $self = shift;
        ok( 1, 'spec test!' );
    };

    # Nested!
    describe ...;
};

1;
---- perl

cases {
    my $self = shift;
    case a => sub {
        my $self = shift;
        $self->reset_data( 'a' );
    }
    case b => sub {
        my $self = shift;
        $self->reset_data( 'b' );
    }
    tests a => sub {
        my $self = shift;
        ok( $self->have_data, "have data" );
    }
    tests b => sub {
        my $self = shift;
        ok( $self->works, "it works" );
    }
}

---- perl
sub setup_my_setup {
    my $self = shift;
    print "methods prefixed by setup_ will be run before tests defined as methods.";
}

sub test_method_as_test_by_prefix {
    my $self = shift;
    ok( 1, "methods prefixed by test_ will be run as method." );
}

sub teardown_my_teardown {
    my $self = shift;
    print "method prefixed by teardown_ will be run after tests defined as methods."
}

---- center

Workflows

----
== Limitations of a screwdriver

 * Test::Builder excels as a base for tools that provide assertion functions

 * Test::Builder does nothing to address workflows

+== Whats a workflow?

+ * A way to structure tests when writing them

+ * A way to structure how tests are run

+ * A way to provide fixture data

+ * A way to setup and teardown an environment around the test
----
== Problems with workflow implementations

 * Often require a 'runner' to take control.

 * Usually do not work well together



+For example, Test::Class Uses a .t file to find, load, and run Test::Class tests.

 * If 2 'runners' find files that look the same (t/.../*.pm) they may stomp eachother

 * What if you want to mix multiple workflows?



+Fennec to the rescue:

 * Fennec provides a base for creating workflows that work together

 * Fennec provides the runner, workflows can simply share it

----
== Fennec Workflow Management

 * Fennec::Workflow base class for custom workflows

 * Tools to simplify defining a workflow in tests

 * Workflows hold child workflows and test sets

 * Workflows return self-contained TestSet objects to the runner

 * Every test file has a 'root' workflow

 * All test groups and workflows are nested within the root workflow

----
== Workflows provided with Fennec

 * Basic - Test groups and child workflows

 * SPEC - An implementation of Ruby's RSPEC for perl

 * Case - Run a set of test groups under multiple cases

 * Module - Similar to Test::Class, tests are methods.
----
== Overview of a workflow structure
-- Root Workflow
   |- Test Group
   |- Another Test Group
   |- Child Workflow
   |  |- Test Group
   |  |- ...
   |
   |- Another Child
      |- Test Group

The workflow process:
 * Load file
   * Create root workflow
   * Add workflows and testgroups defined at package level

 * Initialize/Build child workflows
  * Build workflows to depth

 * Get test sets from each workflow to depth
   (Each workflow returns its own groups and the groups of its children)

 * Run test sets (parallelizable)

---- center

Test files part I.

----
== Test files are objects

 * All packages that 'use Fennec' are subclasses of Fennec::TestFile

+ * Meta Class - TEST::MyTest->fennec_meta()
   * Root workflow
   * Workflow stack
   * Threader
   * META data (todo, skip, file, sort, random)

+ * Construction - TEST::MyTest->fennec_new()
   * Uses new() if your write your own, or use moose
   * Blesses a hashref if their is no custom constructor
     * Calls init() on the new object if you define it
   * Initializes meta class

---- center

Assertions and test utilities

----
== Assertion Library management

 * Every group and workflow generates a result
   * Result passes if the method does not die
   * Result fails if the method dies
   * This allows for 'traditional asserts'

+ * Fennec::Assert - Custom assertions or tester functions
   * Easily create libraries of functions similar to Test::More, etc.
   * Automatically fills in result metadata such as:
     * File name
     * Line number

+ * Fennec::Util::TBOverride
   * Defangs Test::Builder, forces it to report to Fennec
   * Most Test::Builder tools 'just work' under fennec
   * The most popular tools have been wrapped in Fennec::Assert::TBCore
     * Wrapping Test::Builder tools encapsulates errors and results together

---- center

Grouping tests

----
== Test Grouping

 * Tests are grouped into blessed methods

 * Test groups are subclasses of Fennec::TestSet

 * TestSets are what workflows produce

 * Fennec provides a mechanism for you to isolate and run a specific testset

 * TestSets can be run in parrallel

---- perl

tests 'Simple' => sub {
    my $self = shift;
    ok( 1, "Passing" );
    ok( 0, "Failing" );
};

tests 'Complicated' => (
    method => sub { ... },
    # Only report a failure (die)
    no_result => 1,
    # Skip or todo an entire group
    skip => $reason,
    todo => $reason,
);

----
== Fennec::TestSet::SubSet

SubSet is the secret behind the SPEC and Case workflows.

Properties:
    * Tests     (TestSets)
    * Setups    (methods)
    * Teardowns (methods)

 * Runs the setups in the order they were added
 * Runs testsets after setups (usually randomized)
 * Runs the teardowns in reverse order

---- center

Result handling

(Output)

----
== Fennec::Handler

 * Base class for custom output handers

 * All output (results, diags, notes, etc) are passed to handlers

 * Handlers run in, and remain in, the parent process

 * Can run several at once

 * Do anything you want with output objects

----
== Fennec::Handler::TAP

Fennec provides a TAP handler

 * prints outside the TAP handler are redirected to STDERR

 * In a verbose harness (or no harness) errors (diag) appear directly below
   failed results, not off in space (Except for unwrapped Test::Builder tools)

----
== Custom Handlers

 * Can record results in any format, XML, TAP, Custom

 * Can filter results, such as only recording failures

 * Send results to a server, or database

---- center

The Runner

----
== Fennec::Runner

 * Normally kicked off by t/Fennec.t
   * Works with prove
   * Can be configured per-project

 * One runner, unlimited file types, workflows, etc.

 * Parameters can be obtained from:
   * Environment variables
   * Config file (~/ or /etc/)
   * Specified in Fennec.t
   * Sane Defaults

---- center

File Types

----
== Fennec::FileType

 * Specify the types of files to load in the runner

 * Each Fennec::FileType::XXX must implement:

   * $bool = $class->valid_file( $filename )

   * $testclass = $class->load_file( $filename )

   * @paths = $class->paths()

  These 3 methods allows Fennec to work with almost any test file format you
  can concieve.

---- center

Parallelization

----
== Parallelization
 * parallel files
 * parallel tests
  * Grouping
 * Collector
---- perl
== Here is a typical Test::Builder based test

== t/MyModule.t
#!/usr/bin/perl

use strict;
use warnings;
use Test::More;

use_ok( 'MyModule' );

# Sanity
can_ok( 'MyModule', qw/a b/ );
isa_ok( 'MyModule', 'OtherModule' );

#Check defaults
my $one = MyModule->new;
is( MyModule->a, 'a', "default for a" );
is( MyModule->b, 'b', "default for b" );

#Set values
my $two = MyModule->new( a => 'A', b => 'B' );
is( MyModule->a, 'A', "construct value a" );
is( MyModule->b, 'B', "construct value b" );

done_testing;

---- perl
== Here is that same test converted to fennec

== t/MyModule.t
#!/usr/bin/perl
package TEST::MyModule;
use strict;
use warnings;
use Fennec::Standalone;

use_ok( 'MyModule' );

# Sanity
can_ok( 'MyModule', qw/a b/ );
isa_ok( 'MyModule', 'OtherModule' );

#Check defaults
my $one = MyModule->new;
is( MyModule->a, 'a', "default for a" );
is( MyModule->b, 'b', "default for b" );

#Set values
my $two = MyModule->new( a => 'A', b => 'B' );
is( MyModule->a, 'A', "construct value a" );
is( MyModule->b, 'B', "construct value b" );

done_testing;

----
== Differences

+ * The test file declares a package

+ * use Fennec instead of use Test::XXX

---- perl
== Here is that same test converted to fennec

== t/MyModule.t
#!/usr/bin/perl
package TEST::MyModule;
use strict;
use warnings;
use Fennec::Standalone;

use_ok( 'MyModule' );

# Sanity
can_ok( 'MyModule', qw/a b/ );
isa_ok( 'MyModule', 'OtherModule' );

#Check defaults
my $one = MyModule->new;
is( MyModule->a, 'a', "default for a" );
is( MyModule->b, 'b', "default for b" );

#Set values
my $two = MyModule->new( a => 'A', b => 'B' );
is( MyModule->a, 'A', "construct value a" );
is( MyModule->b, 'B', "construct value b" );

done_testing;

---- perl
== Here is that same test written the fennec way

== t/MyModule.pm
package TEST::MyModule;
use strict;
use warnings;
use Fennec;

use_ok( 'MyModule' );

tests Sanity => sub {
    my $self = shift;
    can_ok( 'MyModule', qw/a b/ );
    isa_ok( 'MyModule', 'OtherModule' );
};

tests 'Check defaults' => sub {
    my $one = MyModule->new;
    is( MyModule->a, 'a', "default for a" );
    is( MyModule->b, 'b', "default for b" );
};

tests 'Set values' => sub {
    my $one = MyModule->new( a => 'A', b => 'B' );
    is( MyModule->a, 'A', "construct value a" );
    is( MyModule->b, 'B', "construct value b" );
};

1;
----
== differences

+ * The test file is a module (.pm)

+ * The test groups are named and declared seperately

+ * done_testing() is not required

+ * Test groups are methods
  (notice: $self = shift; in the first group)

----
== The End
