<dl class="listnav">
    <dt id="instance">Instance</dt>
    <dd>
        With Mock::Quick you can mock object instances on the fly, no need for
        a package.

        <script class="code">
            my $obj = qobj(
                method_name1 => 'value',
                method_name2 => qmeth { ... CODE ... },
                method_name3 => sub { "This is a subref as value, not a method" },
            );
        </script>

        This defines an object with 3 methods, the first simply returns a
        value, the second is a custom method, the third returns a subref.

        <script class="code">
            $obj->method_name2( qclear );
        </script>

        This will remove the method code from the method_name2 turning it into
        an empty read/write accessor.

        <script class="code">
            $obj->foo( 'Autovivified Method!' );
        </script>

        Any method you do not define will auto-vivify as a read/write accessor.

        <script class="code">
            my $sobj = qstrict( ... );
        </script>

        This is the same as qobj, except that there is no method
        auto-vivifying.
    </dd>

    <dt id="class">Class</dt>
    <dd>
        You can implement a class, this also prevents the real one from loading
        at all.
        <script class="code">
            my $control = qimplement 'Some::Package' => (
                -with_new => 1,
                -subclass => 'Parent::Class',
                attribute => 'foo',
                method    => sub { ... }
            );
        </script>

        You can takeover an already loaded class, then override any methods on
        that class:
        <script class="code">
            my $control = qtakeover 'Some::Package' => (
                some_method => sub { ... },
                other_meth  => sub { ... },
            );
        </script>

        You can use the control object to apply more overrides, or restore
        original method.
        <script class="code">
            $control->override( foo => sub { ... } );
            ...
            $control->restore( 'foo' );
        </script>

        When the $control object is destroyed, or falls out of scope the
        original methods are all restored.
        <script class="code">
            $control = undef;
            # All methods are restored.
        </script>

        This means you need to pay attention to your control object and make
        sure you store it until it is not needed.
    </dd>

    <dt id="mockfennec">Fennec</dt>
    <dd>
        <h2>What Fennec brings to the party</h2>
        <b>Note: Fennec 2.009 or greater is required for this.</b>
        <p>

        As seen in the previous sections, Mock::Quick functions return a
        control object that you need to keep track of. If you fail to capture
        the control object a warning is issued because your mock is immedietly
        destroyed.
       
        <p>

        In Fennec, Mock::Quick functions where the return object is ignored,
        will act as setup/teardown specifications. That is if you use qtakeover
        in a describe block, the mocking will effect any test blocks (as well
        as setup/teardown blocks) within that describe. The mocking however
        will NOT apply to the describe block itself.

        <p>

        On top of that you can use qtakeover and similar functions inside the
        test block and safely ignore the returned control object.

        <script class="code">
            tests implicit_mock_scope => sub {
                qtakeover Foo => (blah => sub { 'blah' });
                is( Foo->blah, 'blah', "Mock not auto-destroyed" );
            };

            describe detailed_implicit_mock_scope => sub {
                qtakeover Foo => ( outer => 'outer' );
                ok( !Foo->can( 'outer' ), "No Leak" );

                before_all ba => sub {
                    qtakeover Foo => ( ba => 'ba' );
                    can_ok( 'Foo', qw/outer ba/ );
                };

                before_each be => sub {
                    qtakeover Foo => ( be => 'be' );
                    can_ok( 'Foo', qw/outer ba be/ );
                };

                tests the_check => sub {
                    qtakeover Foo => ( inner => 'inner' );

                    can_ok( 'Foo', qw/outer ba be inner/ );
                };

                ok( !Foo->can( 'outer' ), "No Leak" );
                ok( !Foo->can( 'ba' ), "No Leak" );
                ok( !Foo->can( 'be' ), "No Leak" );
                ok( !Foo->can( 'inner' ), "No Leak" );
            };
        </script>
    <dd>
</dl>
