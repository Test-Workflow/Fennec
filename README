NAME
    Fennec - A testers toolbox, and best friend

DESCRIPTION
    Fennec is a testers toolbox, and best friend. Fennec is glue that ties
    together several modules and features to make testing easier, and more
    powerful. Fennec imports all the common Test::* modules for you, in
    addition to several other features.

SYNOPSYS
    There are 2 ways to use Fennec. You can use Fennec directly, or you can
    use the shiny sugar-coated interface provided by the add-on module
    Fennec::Declare.

  DECLARATIVE INTERFACE
    Note: In order to use this you MUST install Fennec::Declare which is a
    seperate distribution on cpan. This module is seperate because it uses
    the controversial Devel::Declare module.

    t/some_test.t: package TEST::SomeTest; use strict; use warnings;

        use Fennec::Declare(
            parallel  => 3,
            test_sort => 'random',
        );

        # This is optional, there is a default 'new' if you do not override it.
        sub new { ... }

        # Test blocks are called as methods on an instance of your test package.
        tests group_1 {
            # Note: $self is automatically shifted for you.
            ok( $self, "Got self automatically" );
        };

        test group_2 ( todo => 'This is not ready yet' ) {
            # Note: $self is automatically shifted for you.
            ok( 0, "Not ready" );
        }

        # This has one test that gets run twice, once for each case.
        # The letter is uppercased before each test is run, but restored to
        # lowercase after each test is run.
        describe complex {
            # Note: $self is automatically shifted for you.

            my $letter;
            case a { $letter => 'a' }
            case b { $letter => 'b' }

            before_each uppercase { $letter = uc $letter }
            after_each  restore   { $letter = lc $letter }

            tests is_letter {
                like( $letter, qr/^[A-Z]$/, "Got a letter" );
            }

            # You can nest describe blocks, test blocks inside will inherit cases
            # and before/after blocks from the parent, and can add additional ones.
            describe inner { ... }
        }

        # It is important to always end a Fennec test with this function call.
        run_test();

  PURE INTERFACE
    If Devel::Declare and its awesome power of syntax specification scares
    you, you can always write your Fennec tests in the stone age like
    this... just don't miss any semicolons.

    t/some_test.t: package TEST::SomeTest; use strict; use warnings;

        use Fennec(
            parallel  => 3,
            test_sort => 'random',
        );

        # This is optional, there is a default 'new' if you do not override it.
        sub new { ... }

        # Test blocks are called as methods on an instance of your test package.
        tests group_1 => sub {
            my $self = shift;
            ok( 1, "1 is true" );
        };

        test group_2 => (
            todo => 'This is not ready yet',
            code => sub {
                my $self = shift;
                ok( 0, "Not ready" );
            }
        );

        # This has one test that gets run twice, once for each case.
        # The letter is uppercased before each test is run, but restored to
        # lowercase after each test is run.
        describe complex => sub {
            my $self = shift;
            my $letter;
            case a => sub { $letter => 'a' };
            case b => sub { $letter => 'b' };

            before_each uppercase => sub { $letter = uc $letter };
            after_each  restore   => sub { $letter = lc $letter };

            tests is_letter => sub {
                like( $letter, qr/^[A-Z]$/, "Got a letter" );
            };

            # You can nest describe blocks, test blocks inside will inherit cases
            # and before/after blocks from the parent, and can add additional ones.
            describe inner => sub { ... };
        };

        # It is important to always end a Fennec test with this function call.
        run_test();

FEATURES
    Forking just works
        Forking in perl tests that use Test::Builder is perilous at best.
        Fennec initiates an Fennec::Collector class which sets up
        Test::Builder to funnel all test results to the main thread for
        rendering. A result of this is that forking just works.

    RSPEC support
        Those familiar with Ruby may already know about the RSPEC testing
        process. In general you "describe" something that is to be tested,
        then you define setup and teardown methods ("before_all",
        "before_each", "after_all", "after_each") and then finally you test
        "it". See the "EXAMPLES" section or Test::Workflow for more details.

    Concurrency, test blocks can run in parallel
        By default all "test" blocks are run in parallel with a cap of 3
        concurrent processes. The process cap can be set with the "parallel"
        import argument.

    No need to maintain a test count
        The test count traditionally was used to ensure your file finished
        running instead of exiting silently too early. With Test::Builder
        and friends this has largely been replaced with the "done_testing()"
        function typically called at the end of tests. Fennec shares this
        concept, except you do not call "done_testing" yourself, "run_tests"
        will do it for you when it finishes.

    Can be decoupled from Test::Builder
        Fennec is built with the assumption that Test::Builder and tools
        built from it will be used. However custom Fennec::Collector and
        Fennec::Runner classes can replace this assumption with any testing
        framework you want to use.

    Can run specific test blocks, excluding others
        Have you ever had a huge test that took a long time to run? Have you
        ever needed to debug a failing test at the end of the file? How many
        times did you need to sit through tests that didn't matter?

        With Fennec you can specify the "FENNEC_TEST" environment variable
        with either a line number or test block name. Only tests defined on
        that line, or with that name will be run.

    Predictability: Rand is always seeded with the date
        Randomizing the order in which test blocks are run can help find
        subtle interaction bugs. At the same time if tests are always in
        random order you cannot reliably reproduce a failure.

        Fennec always seeds rand with the current date. This means that on
        any given date the test run order will always be the same. However
        different days test different orders. You can always specify the
        "FENNEC_SEED" environment variable to override the value used to
        seed rand.

    Test re-ordering, tests can run in random, sorted, or defined order.
        When you load Fennec you can specify a test order. The default is
        random. You can also use the order in which they are defined, or
        sorted (alphabetically) order. If necessary you can pass in a
        sorting function that takes a list of all test-objects as arguments.

    Diag output is coupled with test output
        When you run a Fennec test with a verbose harness (prove -v) the
        diagnostic output will be coupled with the TAP output. This is done
        by sending both output to STDOUT. In a non-verbose harness the
        diagnostics will be sent to STDERR per usual.

    Reusable test modules
        You can write tests in modules using Test::Workflow and then import
        those tests into Fennec tests. This is useful if you have tests that
        you want run in several, or even all test files.

    Works with Moose
        All your test classes are instantiated objects. You can use Moose to
        define these test classes. But you do not have to, you are not
        forced to use OOP in your tests.

DEFAULT IMPORTED MODULES
    Note: These can be overriden either on import, or by subclassing Fennec.

    Mock::Quick - Mocking without the eye gouging
        Mock::Quick is a mocking library that makes mocking easy. In additon
        it uses a declarative style interface. Unlike most other mocking
        libraries on CPAN, it does not make people want to gouge their eyes
        out and curl up in the fetal position.

    Test::Workflow - RSPEC for perl.
        Test::Workflow is a testing library written specifically for Fennec.
        This library provides RSPEC workflow functions and structure. It can
        be useful on its own, but combined with Fennec it gets concurrency.

    Test::More
        Tried and True testing module that everyone uses.

    Test::Warn
        Test::Warn - Test code that issues warnings.

    Test::Exception
        Test::Exception - Test code that throws exceptions

IMPORT ARGUMENTS
    base => 'Some::Base'
        Load the specified module and make it the base class for your test
        class.

    parallel => $PROC_LIMIT
        How many test blocks can be run in parallel. Default is 3. Set to 1
        to fork for each test, but only run one at a time. Set to 0 to
        prevent forking.

    runner_class => 'Fennec::Runner'
        Specify the runner class. You probably don't need this.

    skip_without => [ 'Need::This', 'And::This' ]
        Tell Fennec to skip the test file if any of the specified modules
        are missing.

    test_sort => $SORT
        Options: 'random', 'sorted', 'ordered', or a code block.

        Code block accepts a list of Test::Workflow::Test objects.

    utils => [ 'Test::Foo', ... ]
        Load these modules instead of the default list.

    with_tests => [ 'Reusable::Tests', 'Common::Tests' ]
        Load these modules that have reusable tests. Reusable tests are
        tests that are common to multiple test files.

EXPORTED FUNCTIONS
  FROM FENNEC
    run_tests()
        Should be called at the end of your test file to kick off the RSPEC
        tests. Always returns 1, so you can use it as the last statement of
        your module. You must only ever call this once per test file.

  FROM Test::Workflow
    See Test::Workflow or "EXAMPLES" for more details.

    with_tests 'Module::Name';
        Import tests from a module

    tests $name => sub { ... };
    tests $name => ( %params );
    it $name => sub { ... };
    it $name => ( %params );
        Define a test block

    describe $name => sub { ... };
        Describe a set of tests (group tests and setup/teardown functions)

    case $name => sub { ... };
        Used to run a set of tests against multiple conditions

    before_all $name => sub { ... };
        Setup, run once before any tests in the describe scope run.

    before_each $name => sub { ... };
        Setup, run once per test, just before it runs.

    around_each $name => sub { ... };
        Setup and/or teardown.

    after_each $name => sub { ... };
        Teardown, run once per test, after it finishes.

    after_all $name => sub { ... };
        Teardown, run once, after all tests in the describe scope complete.

  FROM Mock::Quick
    See Mock::Quick or "EXAMPLES" for more details.

    my $control = qclass $CLASS => ( %PARAMS, %OVERRIDES );
    my $control = qtakeover $CLASS => ( %PARAMS, %OVERRIDES );
    my $control = qimplement $CLASS => ( %PARAMS, %OVERRIDES );
    my $control = qcontrol $CLASS => ( %PARAMS, %OVERRIDES );
        Used to define, takeover, or override parts of other packages.

    my $obj = qobj( %PARAMS );
    my ( $obj, $control ) = qobjc( %PARAMS );
    my $obj = qstrict( %PARAMS );
    my ( $obj, $control ) = qstrictc( %PARAMS );
        Define an object specification, quickly.

    my $clear = qclear();
        Used to clear a field in a quick object.

    my $meth = qmeth { ... };
    my $meth = qmeth( sub { ... } );
        Used to define a method for a quick object.

  OTHER
    See Test::More, Test::Warn, and Test::Exception

EXAMPLES
VIM INTEGRATION
    Insert this into your .vimrc file to bind the F8 key to running the test
    block directly under your cursor. You can be on any line of the test
    block (except in some cases the first or last line.

        function! RunFennecLine()
            let cur_line = line(".")
            exe "!FENNEC_TEST='" . cur_line . "' prove -v -I lib %"
        endfunction

        " Go to command mode, save the file, run the current test
        :map <F8> <ESC>:w<cr>:call RunFennecLine()<cr>
        :imap <F8> <ESC>:w<cr>:call RunFennecLine()<cr>

RUNNING FENNEC TEST FILES IN PARALLEL
    The best option is to use prove with the -j flag.

    Note: The following is no longer a recommended practice, it is however
    still supported

    You can also create a custom runner using a single .t file to run all
    your Fennec tests. This has caveats though, such as not knowing which
    test file had problems without checking the failure messages.

    This will find all *.ft and/or *.pm moduls under the t/ directory. It
    will load and run any found. These will be run in parallel

    t/runner.t #!/usr/bin/perl use strict; use warnings;

        # Paths are optional, if none are specified it defaults to 't/'
        use Fennec::Finder( 't/' );

        # The next lines are optional, if you have no custom configuration to apply
        # you can jump right to 'run_tests'.

        # Get the runner (singleton)
        my $runner = Fennec::Finder->new;
        $runner->parallel( 3 );

        # You must call this.
        run();

AUTHORS
    Chad Granum exodist7@gmail.com

COPYRIGHT
    Copyright (C) 2013 Chad Granum

    Fennec is free software; Standard perl license.

    Fennec is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
    FITNESS FOR A PARTICULAR PURPOSE. See the license for more details.

